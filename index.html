<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blink Adventure: Calibration Edition</title>
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #87CEEB; 
            font-family: 'Courier New', Courier, monospace;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; touch-action: none;
        }
        canvas#gameCanvas {
            border: 4px solid #2c3e50;
            background-color: #87CEEB;
            box-shadow: 0px 5px 20px rgba(0,0,0,0.4);
            max-width: 100%; max-height: 100%; width: 800px; height: auto;
            display: block;
        }

        /* UI OVERLAYS */
        #ui-layer {
            position: absolute; top: 10px; left: 10px; right: 10px; pointer-events: none;
            display: flex; flex-direction: column; gap: 8px; max-width: 400px; margin: 0 auto;
        }
        .hud-box {
            background: rgba(44, 62, 80, 0.9); padding: 10px; border: 2px solid #fff;
            color: #fff; border-radius: 8px; pointer-events: auto;
        }
        .top-row { display: flex; justify-content: space-between; align-items: center; }
        #score { font-size: 20px; font-weight: 900; color: #f1c40f; }
        
        /* CALIBRATION SCREEN (The Key Change) */
        #calibration-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.95); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center;
        }
        .cam-container {
            position: relative; width: 320px; height: 240px; background: #000;
            border: 4px solid #fff; margin: 15px 0; border-radius: 8px; overflow: hidden;
        }
        video#webcam {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);
        }
        canvas#debug-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1);
        }
        
        /* METERS & SLIDERS */
        .meter-box { width: 100%; height: 20px; background: #34495e; border: 2px solid #fff; position: relative; border-radius: 10px; overflow: hidden; margin-top:5px;}
        .meter-fill { height: 100%; background: #2ecc71; width: 100%; transition: width 0.05s ease-out; }
        .marker { position: absolute; top: 0; bottom: 0; width: 3px; background: #f1c40f; z-index: 2; height: 100%; box-shadow: 0 0 4px #000; }
        
        button.action-btn {
            background-color: #3498db; color: white; border: 3px solid #fff;
            padding: 12px 30px; font-size: 18px; font-weight: 900;
            cursor: pointer; font-family: inherit; border-radius: 5px; margin-top: 15px;
        }
        button:disabled { background-color: #7f8c8d; opacity: 0.7; cursor: not-allowed; }
        
        .status-badge {
            background: #e74c3c; padding: 5px 10px; border-radius: 4px; font-weight: bold; font-size: 14px; display: inline-block;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" style="display:none;">
        <div class="hud-box top-row">
            <div id="score">0m</div>
            <div id="game-status">RUNNING</div>
        </div>
        <div class="hud-box">
             <div style="font-size:10px; display:flex; justify-content:space-between;">
                <span>EYE OPENNESS</span>
                <span id="blink-text">OPEN</span>
            </div>
            <div class="meter-box" style="height:10px;">
                <div id="game-eye-bar" class="meter-fill"></div>
                <div id="game-thresh-marker" class="marker" style="left: 45%;"></div>
            </div>
        </div>
    </div>

    <div id="calibration-screen">
        <h1 style="margin:0;">CALIBRATION</h1>
        <p style="font-size:12px; opacity:0.8; margin-bottom:5px;">Adjust slider so the bar turns RED when you blink.</p>
        
        <div class="cam-container">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="debug-overlay"></canvas>
        </div>

        <div id="calib-status" class="status-badge">NO FACE DETECTED</div>

        <div style="width: 300px; text-align: left; margin-top: 15px;">
            <div style="display:flex; justify-content:space-between; font-size:12px; font-weight:bold;">
                <label>SENSITIVITY</label> 
                <span id="sens-val">45</span>
            </div>
            <input type="range" id="sensitivity" min="20" max="80" value="45" style="width:100%;">
            
            <div class="meter-box">
                <div id="calib-eye-bar" class="meter-fill"></div>
                <div id="calib-thresh-marker" class="marker" style="left: 45%;"></div>
            </div>
        </div>

        <button id="start-btn" class="action-btn" disabled>LOADING AI...</button>
        <p id="error-log" style="color:#e74c3c; font-size:12px; max-width:300px; display:none;"></p>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        // ELEMENTS
        const video = document.getElementById('webcam');
        const debugCanvas = document.getElementById('debug-overlay');
        const debugCtx = debugCanvas.getContext('2d');
        const startBtn = document.getElementById('start-btn');
        const calibStatus = document.getElementById('calib-status');
        const calibScreen = document.getElementById('calibration-screen');
        const uiLayer = document.getElementById('ui-layer');
        const sensitivitySlider = document.getElementById('sensitivity');
        const sensVal = document.getElementById('sens-val');
        
        // GAME ELEMENTS
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const gameStatusEl = document.getElementById('game-status');

        canvas.width = 800; canvas.height = 400;

        // STATE
        let faceLandmarker = null;
        let lastVideoTime = -1;
        let faceDetected = false;
        let eyeOpenness = 100; // 0-100
        let gameRunning = false;
        let blinkThreshold = 45;

        // GAME VARS
        let player = { x: 150, y: 320, vy: 0, grounded: true };
        let obstacles = [];
        let distance = 0;
        let speedMult = 1;

        // --- 1. INITIALIZATION ---
        async function init() {
            try {
                // Load AI
                const filesetResolver = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: true,
                    runningMode: "VIDEO",
                    numFaces: 1
                });

                // Start Camera
                startBtn.innerText = "ACCESSING CAM...";
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 320, height: 240, facingMode: "user" } 
                });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    startBtn.innerText = "START GAME";
                    startBtn.disabled = false;
                    predictWebcam();
                });

            } catch(e) {
                document.getElementById('error-log').innerText = e.message;
                document.getElementById('error-log').style.display = 'block';
                startBtn.innerText = "ERROR";
            }
        }
        init();

        // --- 2. VISION LOOP (Calibration & Game) ---
        async function predictWebcam() {
            let now = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, now);
                
                // Clear Debug Canvas
                debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
                debugCanvas.width = video.videoWidth;
                debugCanvas.height = video.videoHeight;

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    faceDetected = true;
                    calibStatus.innerText = "FACE DETECTED";
                    calibStatus.style.background = "#2ecc71"; // Green
                    
                    const landmarks = results.faceLandmarks[0];
                    
                    // Draw Face Dots (Visual Feedback)
                    debugCtx.fillStyle = "#e74c3c"; 
                    landmarks.forEach((p, i) => {
                        // Draw only every 10th point to save perf, plus eyes
                        if(i % 10 === 0 || (i > 130 && i < 160) || (i > 360 && i < 390)) {
                            debugCtx.beginPath();
                            debugCtx.arc(p.x * debugCanvas.width, p.y * debugCanvas.height, 2, 0, 2*Math.PI);
                            debugCtx.fill();
                        }
                    });

                    // Calculate Eye Openness
                    const leftEAR = getEAR(landmarks, 159, 145, 33, 133);
                    const rightEAR = getEAR(landmarks, 386, 374, 362, 263);
                    let avg = (leftEAR + rightEAR) / 2;
                    // Calibrated mapping
                    eyeOpenness = Math.max(0, Math.min(100, (avg - 0.18) * 600)); 

                } else {
                    faceDetected = false;
                    calibStatus.innerText = "NO FACE";
                    calibStatus.style.background = "#e74c3c"; // Red
                    eyeOpenness = 100;
                }

                updateMeters();
            }
            window.requestAnimationFrame(predictWebcam);
        }

        function getEAR(lm, t, b, i, o) {
            const dv = Math.hypot(lm[t].x - lm[b].x, lm[t].y - lm[b].y);
            const dh = Math.hypot(lm[i].x - lm[o].x, lm[i].y - lm[o].y);
            return dv / dh;
        }

        function updateMeters() {
            blinkThreshold = parseInt(sensitivitySlider.value);
            sensVal.innerText = blinkThreshold;

            // Update Calibration UI
            const calibBar = document.getElementById('calib-eye-bar');
            const calibMarker = document.getElementById('calib-thresh-marker');
            if(calibBar) {
                calibBar.style.width = eyeOpenness + "%";
                calibMarker.style.left = blinkThreshold + "%";
                calibBar.style.background = (eyeOpenness < blinkThreshold) ? "#e74c3c" : "#2ecc71"; // Red if blinking
            }

            // Update Game UI
            const gameBar = document.getElementById('game-eye-bar');
            const gameMarker = document.getElementById('game-thresh-marker');
            if(gameBar) {
                gameBar.style.width = eyeOpenness + "%";
                gameMarker.style.left = blinkThreshold + "%";
                gameBar.style.background = (eyeOpenness < blinkThreshold) ? "#e74c3c" : "#2ecc71";
            }
        }

        // --- 3. GAME CONTROL ---
        startBtn.addEventListener('click', () => {
            if(!faceDetected) {
                alert("Cannot start: No face detected! Please adjust your lighting.");
                return;
            }
            calibScreen.style.display = 'none';
            uiLayer.style.display = 'block';
            resetGame();
            gameRunning = true;
            gameLoop();
        });

        function resetGame() {
            player.y = 320; player.vy = 0; player.grounded = true;
            obstacles = [{ x: 0, y: 350, w: 800, h: 50, type: 'floor' }];
            distance = 0; scoreEl.innerText = "0m";
        }

        function updateGame() {
            const isBlink = eyeOpenness < blinkThreshold;
            const moving = faceDetected; 

            // Logic
            if (player.grounded) {
                if (isBlink) {
                    player.vy = -14; 
                    player.grounded = false;
                    gameStatusEl.innerText = "JUMP!";
                } else {
                    gameStatusEl.innerText = moving ? "RUNNING" : "WAITING FOR FACE";
                    gameStatusEl.style.color = moving ? "#2ecc71" : "#e74c3c";
                }
            }
            
            player.vy += 0.6; // Gravity
            player.y += player.vy;

            if (moving) {
                distance += 5 * speedMult;
                scoreEl.innerText = Math.floor(distance/10) + "m";
                obstacles.forEach(ob => ob.x -= 5 * speedMult);
                spawnTerrain();
            }

            // Floor Collision
            let onGround = false;
            obstacles.forEach(ob => {
                if(ob.type === 'floor') {
                    if(player.x > ob.x && player.x < ob.x + ob.w &&
                       player.y + 15 >= ob.y && player.y - 15 <= ob.y + ob.h && player.vy >= 0) {
                        player.y = ob.y - 15; player.vy = 0; player.grounded = true; onGround = true;
                    }
                } else if(ob.type !== 'pit') {
                     // Hit tree/house
                     if(player.x+10 > ob.x && player.x-10 < ob.x + ob.w && player.y+10 > ob.y) {
                         gameOver();
                     }
                }
            });
            
            if(player.y > 450) gameOver();
            obstacles = obstacles.filter(ob => ob.x + ob.w > -100);
        }

        function spawnTerrain() {
            let last = obstacles[obstacles.length-1];
            if(last.x + last.w < 850) {
                let isPit = Math.random() < 0.2;
                let x = last.x + last.w;
                if(isPit) {
                    obstacles.push({x: x, y: 350, w: 100, h:0, type:'pit'});
                } else {
                    let w = 200 + Math.random()*300;
                    obstacles.push({x: x, y: 350, w: w, h:50, type:'floor'});
                    if(Math.random() < 0.4) {
                        obstacles.push({x: x+50, y: 290, w: 30, h: 60, type:'tree'});
                    }
                }
            }
        }

        function drawGame() {
            ctx.clearRect(0,0,800,400);
            obstacles.forEach(ob => {
                if(ob.type === 'floor') { ctx.fillStyle = "#5d4037"; ctx.fillRect(ob.x, ob.y, ob.w, ob.h); ctx.fillStyle="#2ecc71"; ctx.fillRect(ob.x, ob.y, ob.w, 10); }
                if(ob.type === 'tree') { ctx.fillStyle = "#27ae60"; ctx.beginPath(); ctx.moveTo(ob.x+15, ob.y); ctx.lineTo(ob.x, ob.y+60); ctx.lineTo(ob.x+30, ob.y+60); ctx.fill(); }
            });
            ctx.fillStyle = "#8B4513"; ctx.fillRect(player.x-15, player.y-15, 30, 30);
            ctx.fillStyle = "red"; ctx.fillRect(player.x+12, player.y-5, 5, 5);
        }

        function gameOver() {
            gameRunning = false;
            alert("GAME OVER! Score: " + Math.floor(distance/10) + "m");
            resetGame();
            gameRunning = true;
        }

        function gameLoop() {
            if(gameRunning) { updateGame(); drawGame(); }
            requestAnimationFrame(gameLoop);
        }

    </script>
</body>
</html>

